using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.Primitives;
using System;
using System.Text;
using System.Threading.Tasks;

namespace JobBank.Server
{
    /// <summary>
    /// Exposes jobs and promises from a Job Bank server to HTTP clients. 
    /// </summary>
    /// <remarks>
    /// As the HTTP endpoints need to expose arbitrary payloads efficiently,
    /// the MVC (Model-View-Controller) framework and model-binding are not used.
    /// HTTP endpoints are implemented in the "raw" ASP.NET Core API.
    /// </remarks>
    public static class JobsHttpExtensions
    {
        /// <summary>
        /// Accept jobs of a certain type to be posted at a specific HTTP endpoint. 
        /// </summary>
        /// <param name="endpoints">Builds all the HTTP endpoints used by the application. </param>
        /// <param name="promiseStorage">Stores the promises that are generated by job postings. </param>
        /// <param name="routeKey">Sub-path occurring after the URL prefix for Job Bank that 
        /// is specific to job executor being registered.
        /// </param>
        /// <param name="executor">Processes the jobs' inputs and provides the results into
        /// the created promises.
        /// </param>
        /// <returns>Builder specific to the new job executor's endpoint that may be
        /// used to customize its handling by the ASP.NET Core framework.
        /// </returns>
        public static IEndpointConventionBuilder 
            MapPostJob(this IEndpointRouteBuilder endpoints,
                       PromiseStorage promiseStorage,
                       string routeKey,
                       JobExecutor executor)
        {
            return endpoints.MapPost(
                    "/jobs/v1/queue/" + routeKey,
                    httpContext => PostJobAsync(promiseStorage, httpContext, routeKey, executor));
        }

        /// <summary>
        /// Encodes strings to UTF-8 without the so-called "byte order mark".
        /// </summary>
        private static readonly Encoding Utf8NoBOM = new UTF8Encoding(false);

        /// <summary>
        /// Translate a .NET exception to an HTTP response to the client as best
        /// as possible.
        /// </summary>
        private static async Task TranslateExceptionToHttpResponseAsync(Exception e,
                                                                        HttpResponse httpResponse)
        {
            if (e is PayloadTooLargeException)
            {
                httpResponse.StatusCode = StatusCodes.Status413PayloadTooLarge;
            }
            else
            {
                httpResponse.StatusCode = StatusCodes.Status400BadRequest;

                var bytes = Utf8NoBOM.GetBytes(e.ToString());

                httpResponse.ContentType = "text/plain";
                httpResponse.ContentLength = bytes.Length;

                await httpResponse.BodyWriter.WriteAsync(bytes).ConfigureAwait(false);
                httpResponse.BodyWriter.Complete();
            }

        }

        /// <summary>
        /// Invokes a job executor to process a job posted by an HTTP client.
        /// </summary>
        private static async Task PostJobAsync(PromiseStorage promiseStorage, 
                                               HttpContext httpContext,
                                               string routeKey,
                                               JobExecutor executor)
        {
            var httpRequest = httpContext.Request;
            var httpResponse = httpContext.Response;
            var cancellationToken = httpContext.RequestAborted;
            Promise promise;

            try
            {
                promise = promiseStorage.CreatePromise();

                var jobInput = new JobInput(httpRequest.ContentType,
                                            httpRequest.ContentLength,
                                            httpRequest.BodyReader,
                                            cancellationToken);

                Job job = await executor.Invoke(jobInput, promise.Id)
                                        .ConfigureAwait(false);

                promise.AwaitAndPostResult(job.Task);

                await job.RequestReadingDone;
            }
            catch (Exception e)
            {
                await TranslateExceptionToHttpResponseAsync(e, httpResponse).ConfigureAwait(false);
                return;
            }

            httpResponse.StatusCode = StatusCodes.Status303SeeOther;
            httpResponse.Headers.Add("x-job-id", promise.Id.ToString());

            // URL encoding??
            httpResponse.Headers.Location = $"/jobs/v1/id/{promise.Id.ServiceId:X8}/{promise.Id.SequenceNumber}";
        }

        /// <summary>
        /// Reads out data for a cached promise at an input path and sends it to the HTTP client.
        /// </summary>
        /// <param name="endpoints">Builds all the HTTP endpoints used by the application. </param>
        /// <param name="promiseStorage">Stores the promises that are generated by job postings. </param>
        /// <returns>Builder specific to the new job executor's endpoint that may be
        /// used to customize its handling by the ASP.NET Core framework.
        /// </returns>
        public static IEndpointConventionBuilder
            MapGetPromise(this IEndpointRouteBuilder endpoints,
                          PromiseStorage promiseStorage)
        {
            // FIXME This should be managed by a cache
            IPromiseClientInfo clientInfo = new BasicPromiseClientInfo();

            return endpoints.MapGet(
                    "/jobs/v1/id/{serviceId}/{sequenceNumber}",
                    httpContext => GetPromiseAsync(promiseStorage, httpContext, clientInfo));
        }

        private static async Task GetPromiseAsync(PromiseStorage promiseStorage, 
                                                  HttpContext httpContext,
                                                  IPromiseClientInfo client)
        {
            var httpRequest = httpContext.Request;
            var httpResponse = httpContext.Response;
            var cancellationToken = httpContext.RequestAborted;

            var serviceIdStr = (string)httpContext.GetRouteValue("serviceId")!;
            var sequenceNumberStr = (string)httpContext.GetRouteValue("sequenceNumber")!;
            if (!PromiseId.TryParse(serviceIdStr, sequenceNumberStr, out var promiseId))
            {
                httpResponse.StatusCode = StatusCodes.Status400BadRequest;
                return;
            }

            if (!httpRequest.Query.TryGetValue("timeout", out var timeoutString))
                timeoutString = StringValues.Empty;
            var timeout = TimeSpan.Zero;
            if (timeoutString.Count == 1 && !string.IsNullOrEmpty(timeoutString[0]))
                ExpiryTimeSpan.TryParse(timeoutString[0], out timeout);

            var promise = promiseStorage.GetPromiseById(promiseId);
            if (promise == null)
            {
                httpResponse.StatusCode = StatusCodes.Status404NotFound;
                return;
            }

            if (timeout == TimeSpan.Zero && !promise.IsCompleted)
            {
                httpResponse.StatusCode = StatusCodes.Status204NoContent;
                return;
            }

            using var result = await promise.GetResultAsync(client, timeout, cancellationToken)
                                            .ConfigureAwait(false);
            var output = result.NormalOutput;

            var pipeReader = await output.GetPipeReaderAsync(output.SuggestedContentType, 0, cancellationToken)
                                         .ConfigureAwait(false);

            httpResponse.StatusCode = StatusCodes.Status200OK;
            httpResponse.ContentType = output.SuggestedContentType;
            httpResponse.ContentLength = output.ContentLength;

            await pipeReader.CopyToAsync(httpResponse.BodyWriter, cancellationToken);
        }


        public static void MapHttpRoutes(this IEndpointRouteBuilder endpoints, 
                                         PromiseStorage promiseStorage,
                                         string routeKey,
                                         JobExecutor executor)
        {
            routeKey = routeKey.Trim('/');

            endpoints.MapPostJob(promiseStorage, routeKey, executor);
            endpoints.MapGetPromise(promiseStorage);
        }
    }
}
