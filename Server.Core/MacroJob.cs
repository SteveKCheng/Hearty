using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using JobBank.Scheduling;
using JobBank.Utilities;

namespace JobBank.Server;

using JobMessage = ScheduledJob<PromisedWork, PromiseData>;
using MacroJobExpansion = IAsyncEnumerable<(PromiseRetriever, PromisedWork)>;

/// <summary>
/// The message type put into the queues managed by
/// <see cref="JobSchedulingSystem" /> that implements
/// a "macro job".
/// </summary>
/// <remarks>
/// <para>
/// A "macro job" expands into many "micro jobs" only when
/// the macro job is de-queued.  This feature avoids 
/// having to push hundreds and thousands of messages 
/// (for the micro jobs) into the queue which makes it
/// hard to visualize and manage.  Resources can also
/// be conserved if the generator of the micro jobs
/// is able to, internally, represent micro jobs more 
/// efficiently than generic messages in the job
/// scheduling queues.
/// </para>
/// <para>
/// A user-supplied generator
/// lists out the micro jobs as <see cref="PromisedWork" />
/// descriptors, and this class transforms them into
/// the messages that are put into the job queue,
/// to implement job sharing and time accounting.
/// </para>
/// </remarks>
internal class MacroJobMessage : IAsyncEnumerable<JobMessage>
{
    private readonly MacroJobExpansion _expansion;

    private readonly JobSchedulingSystem _jobScheduling;
    private readonly ClientJobQueue _queue;
    private readonly PromiseId _promiseId;
    private readonly IPromiseListBuilder _resultBuilder;

    /// <summary>
    /// Provides the cancellation token for all micro jobs
    /// spawned from this macro job.
    /// </summary>
    /// <remarks>
    /// This token allows the micro jobs to be cancelled along
    /// with this macro job when only this macro job is to be
    /// cancelled, even if the cancellation token passed externally
    /// is linked to other operations.
    /// </remarks>
    private CancellationSourcePool.Use _rentedCancellationSource;

    /// <summary>
    /// Links the cancellation token passed in the constructor
    /// into <see cref="_rentedCancellationSource" />.
    /// </summary>
    private CancellationTokenRegistration _cancellationRegistration;

    /// <summary>
    /// Flagged to non-zero as soon as <see cref="GetAsyncEnumerator" />
    /// is called, to disallow multiple calls.
    /// </summary>
    /// <remarks>
    /// Enumeration of micro jobs can only be done once per instance
    /// of this class, because the jobs involve registrations that have
    /// to be accessed outside of the enumerator and cleaned up after
    /// the jobs finish executing.  Obviously, these registrations
    /// cannot be scoped to the enumerator instance.
    /// </remarks>
    private int _jobStarted;

    /// <summary>
    /// Construct the macro job message.
    /// </summary>
    /// <param name="expansion">
    /// User-supplied generator that lists out
    /// the promise objects and work descriptions for
    /// the micro jobs.
    /// </param>
    /// <param name="jobScheduling">
    /// The job scheduling system that this message is for.
    /// This reference is needed to push micro jobs into
    /// the job queue.
    /// </param>
    /// <param name="queue">
    /// The job queue that micro jobs will be pushed into.
    /// </param>
    /// <param name="promiseId">
    /// The promise ID for the macro job, needed to unregister
    /// it from <paramref name="jobScheduling" /> when the macro
    /// job has finished expanding.
    /// </param>
    /// <param name="resultBuilder">
    /// The list of promises generated by <paramref name="expansion" />
    /// will be stored/passed onto here.
    /// </param>
    /// <param name="cancellationToken">
    /// Cancellation token for the macro job.
    /// For efficiency, all the micro jobs expanded from
    /// this macro job will share the same cancellation source,
    /// and micro jobs cannot be cancelled independently
    /// of one another.
    /// </param>
    internal MacroJobMessage(MacroJobExpansion expansion,
                             JobSchedulingSystem jobScheduling,
                             ClientJobQueue queue,
                             PromiseId promiseId,
                             IPromiseListBuilder resultBuilder,
                             CancellationToken cancellationToken)
    {
        _expansion = expansion;
        _jobScheduling = jobScheduling;
        _queue = queue;
        _promiseId = promiseId;
        _resultBuilder = resultBuilder;
        _rentedCancellationSource = CancellationSourcePool.Rent();

        _cancellationRegistration = cancellationToken.Register(
            static s => Unsafe.As<MacroJobMessage>(s!).Cancel(),
            this);
    }

    public void Cancel()
    {
        _rentedCancellationSource.Source?.Cancel();
    }

    /// <inheritdoc cref="IAsyncEnumerable{T}.GetAsyncEnumerator" />
    public async IAsyncEnumerator<JobMessage>
        GetAsyncEnumerator(CancellationToken cancellationToken = default)
    {
        if (Interlocked.Exchange(ref _jobStarted, 1) != 0)
        {
            throw new NotSupportedException(
                "Enumerator for MacroJobMessage may not be retrieved " +
                "more than once. ");
        }

        int count = 0;
        Exception? exception = null;
        CancellationToken jobCancelToken = _rentedCancellationSource.Token;

        // Whether an exception indicates cancellation from the token
        // passed into this enumerator.
        static bool IsLocalCancellation(Exception e, CancellationToken c)
            => e is OperationCanceledException ec && ec.CancellationToken == c;

        //
        // We cannot write the following loop as a straightforward
        // "await foreach" with "yield return" inside, because
        // we need to catch exceptions.  We must control the
        // enumerator manually.
        //

        IAsyncEnumerator<(PromiseRetriever, PromisedWork)>? enumerator = null;
        try
        {
            // Do not do anything if another producer has already completed.
            if (_resultBuilder.IsComplete)
                yield break;

            if (!jobCancelToken.IsCancellationRequested)
                enumerator = _expansion.GetAsyncEnumerator(cancellationToken);
        }
        catch (Exception e) when (!IsLocalCancellation(e, cancellationToken))
        {
            exception = e;
        }

        if (enumerator is not null)
        {
            while (true)
            {
                JobMessage? message;

                try
                {
                    if (jobCancelToken.IsCancellationRequested)
                        break;

                    // Stop generating job messages if another producer
                    // has completely done so, or there are no more micro jobs.
                    if (_resultBuilder.IsComplete ||
                        !await enumerator.MoveNextAsync().ConfigureAwait(false))
                        break;

                    if (jobCancelToken.IsCancellationRequested)
                        break;

                    var (promiseRetriever, input) = enumerator.Current;

                    message = _jobScheduling.RegisterJobMessage(
                                    _queue.SchedulingAccount,
                                    promiseRetriever,
                                    input,
                                    jobCancelToken,
                                    out var promise);

                    // Add the new member to the result sequence.
                    _resultBuilder.SetMember(count, promise);
                    count++;

                    // Do not schedule work if promise is already complete
                    if (message is null)
                        continue;
                }
                catch (Exception e) when (!IsLocalCancellation(e, cancellationToken))
                {
                    exception = e;
                    break;
                }

                yield return message.GetValueOrDefault();
            }

            try
            {
                await enumerator.DisposeAsync().ConfigureAwait(false);
            }
            catch (Exception e) when (!IsLocalCancellation(e, cancellationToken))
            {
                exception ??= e;
            }
        }

        if (jobCancelToken.IsCancellationRequested && exception is null)
        {
            // Do not need to block waiting for our callback to complete
            // because cancellation source has already been triggered,
            // and it cannot be returned to the pool anyway.
            _cancellationRegistration.Unregister();
            _cancellationRegistration = default;

            // Complete _resultBuilder with the cancellation exception
            // only if this producer is the last to cancel.
            if (_jobScheduling.UnregisterMacroJob(_promiseId, toCancel: true))
            {
                exception = new OperationCanceledException(jobCancelToken);
                _resultBuilder.TryComplete(count, exception);
            }
        }
        else
        {
            // When this producers finishes successfully without
            // job cancellation, complete _resultBuilder.
            bool isFirst = _resultBuilder.TryComplete(count, exception);
            _ = CleanUpAsync(isFirst);
        }
    }

    /// <summary>
    /// Wait for all promises to complete before executing successful
    /// clean-up action.
    /// </summary>
    /// <param name="isFirst">
    /// Whether this instance is the first to complete 
    /// <see cref="_resultBuilder" />, thus triggering clean-up
    /// action shared for all clients requesting the same macro job.
    /// </param>
    private async Task CleanUpAsync(bool isFirst)
    {
        try
        {
            await _resultBuilder.WaitForAllPromisesAsync()
                                .ConfigureAwait(false);
        }
        catch
        {
        }

        try
        {
            _cancellationRegistration.Dispose();
            _cancellationRegistration = default;

            _rentedCancellationSource.Dispose();
        }
        catch
        {
        }

        // If this producer is the first producer then unregister
        // the promise as well.  UnregisterMacroPromise could be
        // called unconditionally here and it would do nothing
        // if this is not the first producer.
        if (isFirst)
            _jobScheduling.UnregisterMacroJob(_promiseId, toCancel: false);
    }
}
